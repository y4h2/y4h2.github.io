(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{520:function(e,t,s){"use strict";s.r(t);var r=s(6),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("With the user number increment, a single MySQL instance's performance is not enough for traffics. Then we could consider MySQL clusters.")]),e._v(" "),s("h1",{attrs:{id:"mysql-cluster"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql-cluster"}},[e._v("#")]),e._v(" MySQL Cluster")]),e._v(" "),s("p",[e._v("MySQL cluster is always composed of one master server and multiple slave servers. The slave machines act as the read replica of the master server.\nThe slave machines subscribe to the master server's binlog, once write operations happen on the master machine, new binlog will trigger slaves to update. However, there is a data delay before updated data reach slaves.")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/y4h2/y4h2.github.io/imagebed/img/blog/20210326211847.png",alt:""}})]),e._v(" "),s("p",[e._v("Because of this MySQL architecture, the master server could serve both write and read operations, but slaves only receive reading operations. Based on this acknowledgment, it's easy to infer to Read/Write Splitting structure.")]),e._v(" "),s("h1",{attrs:{id:"read-write-splitting"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#read-write-splitting"}},[e._v("#")]),e._v(" Read/Write Splitting")]),e._v(" "),s("p",[e._v("As the name suggests, we split read and write SQL, send reading sentences to any slaves, and writing sentences to the master node. In applications, to achieve Read/Write Splitting, we could treat the cluster as separated instances; for each instance, we set up a connection pool. Depends on the type of SQL, the application sends SQL to corresponding DB instances.\nThe above way sounds a bit dummy; here, we could do some simplification to remove replicated code to some extent.")]),e._v(" "),s("ul",[s("li",[e._v("Use Regular Expression to match the SQL sentence, but it cannot satisfy all cases.")]),e._v(" "),s("li",[e._v("Use wrapper functions to encapsulate SELECT, INSERT, DELETE, UPDATE separately. It's similar to ORM's work, so you could try to use ORM directly. In Golang's world, "),s("a",{attrs:{href:"https://gorm.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Gorm"),s("OutboundLink")],1),e._v(" supports read/write spliting.")]),e._v(" "),s("li",[e._v("Use proxies instead of implementing the logic in the application, outsourcing the logic to a MySQL proxy is also a good practice.")])]),e._v(" "),s("p",[e._v("Here is the Golang code example: "),s("a",{attrs:{href:"https://github.com/walu/wgf/blob/master/src/wgf/lib/sqlutil/db.go#L40",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/walu/wgf/blob/master/src/wgf/lib/sqlutil/db.go#L40"),s("OutboundLink")],1)]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/y4h2/y4h2.github.io/imagebed/img/blog/20210326212229.png",alt:""}})]),e._v(" "),s("p",[e._v("Also, because of the data delay between master and slave machines, if some business logics requires strong consistency, all operations have to be sent to the master node. Read replica could only be used for logics could tolenrant eventually consistency.")]),e._v(" "),s("h1",{attrs:{id:"read-write-splitting-with-proxy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#read-write-splitting-with-proxy"}},[e._v("#")]),e._v(" Read/Write Splitting With Proxy")]),e._v(" "),s("p",[e._v('As we mentioned above, we could add a proxy between the application and the MySQL cluster, which is transparent.\nIt sounds beautiful; however, "no silver bullet", using proxy also has it\'s limitations.')]),e._v(" "),s("ul",[s("li",[e._v("Performance loss: Most proxies will not forward SQL directly; it needs to parse SQL first and determines which DB server it goes to. Also, there is one more level between the application and the DB, it will have some extent performance loss.")]),e._v(" "),s("li",[e._v("The proxy is not intelligent as you expected: it might not support some SQL grammar or SQL functions. Sometimes, in our application, we need to force the proxy to select master node instead of slave nodes, which means we cannot make it 100% transparent.")]),e._v(" "),s("li",[e._v("Maintenance costs\n"),s("ul",[s("li",[e._v('"no application is perfect" the rule also applies to the proxy. Sometimes, the error might be caused by proxy itself. It adds costs of debugging issues.')]),e._v(" "),s("li",[e._v("you need to maintain one more proxy.")])])])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/y4h2/y4h2.github.io/imagebed/img/blog/20210326212257.png",alt:""}})]),e._v(" "),s("h1",{attrs:{id:"corresponding-aws-services"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#corresponding-aws-services"}},[e._v("#")]),e._v(" Corresponding AWS Services")]),e._v(" "),s("p",[e._v("If you are using AWS services, it's very easy to set up a MySQL cluster. You could set up a read replica with a few clicks. "),s("a",{attrs:{href:"https://aws.amazon.com/rds/features/read-replicas/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://aws.amazon.com/rds/features/read-replicas/"),s("OutboundLink")],1),e._v(" (Although I still recommend using CloudFormation or other IaC tool)\nAWS also has managed RDS proxy. "),s("a",{attrs:{href:"https://aws.amazon.com/rds/proxy/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://aws.amazon.com/rds/proxy/"),s("OutboundLink")],1)]),e._v(" "),s("p",[e._v("Furthermore, AWS Aurora Serverless removes the concerns of setting up MySQL cluster. In theory, you even don't need to worry about scaling issues anymore. "),s("a",{attrs:{href:"https://aws.amazon.com/rds/aurora/serverless/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://aws.amazon.com/rds/aurora/serverless/"),s("OutboundLink")],1)]),e._v(" "),s("h1",{attrs:{id:"conclusion"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" Conclusion")]),e._v(" "),s("p",[e._v("In this article, we introduced the MySQL cluster architecture. Based on the architecture, it's easy to infer the usage of Read/Write Splitting. We also discussed that involving Read/Write Splitting in your application is not hard. To simplify it one more step, we have talked about three solutions. For the proxy solution, we have dived deeply into its drawbacks.\nRead/Write Splitting is a scaling way to extend your application's read performance. However, because of the MySQL cluster structure, it cannot promote write performance. Whether applying read/write spliting depends on the scale of your application")]),e._v(" "),s("h1",{attrs:{id:"what-s-more"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what-s-more"}},[e._v("#")]),e._v(" What's More")]),e._v(" "),s("p",[e._v("MySQL Proxy: kingshard, ProxySQL\nTo set up a testing environment, I would recommend using a pre-configured MySQL cluster in docker-compose. "),s("a",{attrs:{href:"https://github.com/vbabak/docker-mysql-master-slave",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/vbabak/docker-mysql-master-slave"),s("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);