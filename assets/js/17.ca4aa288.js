(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{523:function(e,t,s){"use strict";s.r(t);var a=s(6),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("In this article, I am going to show three common distributed system models with diagrams based on the CAP theorem.")]),e._v(" "),s("p",[e._v('CAP theorem: "'),s("em",[e._v('it is impossible for a distributed data store to simultaneously provide more than two out of the following three guarantees: Consistency, Availability, Partition tolerance."')])]),e._v(" "),s("ul",[s("li",[e._v("Consistency means, in a distributed system, all nodes should keep the same data.")]),e._v(" "),s("li",[e._v("Availability means, in a distributed system, every request needs to be responded")]),e._v(" "),s("li",[e._v("Partition tolerance means the distributed system should still work when the network partition failure happens.\nIn a distributed system, we should always guarantee partition tolerance. Otherwise, it will become multiple single systems instead of one distributed system when the network partition issue happens. Thus when we design a system, we need to play balance between AP and CP systems.")])]),e._v(" "),s("h1",{attrs:{id:"ap-system"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ap-system"}},[e._v("#")]),e._v(" AP System")]),e._v(" "),s("p",[e._v("In an AP system, availability is the priority.\nAs the diagram shows")]),e._v(" "),s("ol",[s("li",[e._v("user sends a request to store data")]),e._v(" "),s("li",[e._v("once the "),s("code",[e._v("node1")]),e._v(' stores data locally, it returns "success" to the user immediately.\n'),s("ol",[s("li",[e._v("at this moment, node2 and node3 don't have data yet. So for the whole system, data is not consistent. If users connect to node2 or node3 at this time, they cannot see the updated data.")]),e._v(" "),s("li",[e._v("the system keeps the availability; when users send requests, they can always get responses back.")])])]),e._v(" "),s("li",[e._v("Sync data to node2 and node3. Before node2 and node3 have the data, the system is not consistent.")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/y4h2/y4h2.github.io/imagebed/img/blog/20210326205831.png",alt:""}})]),e._v(" "),s("h1",{attrs:{id:"cp-system"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cp-system"}},[e._v("#")]),e._v(" CP System")]),e._v(" "),s("ol",[s("li",[e._v("the user sends a request to the system to store data")]),e._v(" "),s("li",[e._v("node1 receives the request and store data locally, then node1 sync data to node2 and node3, once both nodes acknowledge that they have received data, node1 will respond back to user\n"),s("ol",[s("li",[e._v("the system is always consistent, because user is only able to get data when all nodes have the same record.")]),e._v(" "),s("li",[e._v("the system's availability is influenced. Between the sending request and getting response, the system is not available to the origin user.")])])]),e._v(" "),s("li",[e._v('once data is synced on all nodes, node1 responds "success" to the user.')])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/y4h2/y4h2.github.io/imagebed/img/blog/20210326211038.png",alt:""}})]),e._v(" "),s("h1",{attrs:{id:"balanced-system"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#balanced-system"}},[e._v("#")]),e._v(" Balanced System")]),e._v(" "),s("p",[e._v("Instead of using the total CP or AP system, we could keep the balance between CP and AP.")]),e._v(" "),s("ol",[s("li",[e._v("the user sends a request to the system to store data")]),e._v(" "),s("li",[e._v("node1 stores data to the local and tries to sync data to node2 and node3. In this architecture, once any of node2 and node3 acknowledges that the data is received, the "),s("code",[e._v("node1")]),e._v(" will responds to the user\n"),s("ol",[s("li",[e._v("the system makes sure more than half nodes contain the data")]),e._v(" "),s("li",[e._v("the availability is sacrificed partially (it doesn't respond success immediately),  but the system gets higher consistency (more than half of nodes are updated)")])])]),e._v(" "),s("li",[e._v("the user gets the response when at least half nodes are updated.")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/y4h2/y4h2.github.io/imagebed/img/blog/20210326211110.png",alt:""}})]),e._v(" "),s("h1",{attrs:{id:"what-s-more"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what-s-more"}},[e._v("#")]),e._v(" What's More?")]),e._v(" "),s("p",[e._v("The above three systems are just theoretical models to help us to understand AP and CP systems.")]),e._v(" "),s("p",[e._v("In the real world, we need to consider more situations, like if some nodes are down how could we recover the data. We have a lot of distributed protocols to help us to set up the distributed system and make the system stable.\nDuring our daily work, it's far away from designing a distributed data system. But we could use the CAP theorem to analyze questions.\nFor example, a system provides content storage and full-text search services to users; it uses MySQL as the source of truth to store documents and uses Elasticsearch as the search engine. When a request comes in, the data needs to be stored on both MySQL and ES.\n"),s("img",{attrs:{src:"https://raw.githubusercontent.com/y4h2/y4h2.github.io/imagebed/img/blog/20210326211129.png",alt:""}})]),e._v(" "),s("ul",[s("li",[e._v("To design an AP system, once the app receives the request, it returns 202 immediately, the storage to DB and ES is running async.")]),e._v(" "),s("li",[e._v("To design a CP system, the app only responds to the user when both DB and ES get updated successfully.")]),e._v(" "),s("li",[e._v("To design a balanced system, the app store the data to the DB and responds 200, and runs ES query in the background.")])]),e._v(" "),s("p",[e._v("Choosing which system depends on our requirements, but the CAP theorem is a good tool for analyzing our architecture.")])])}),[],!1,null,null,null);t.default=o.exports}}]);